{
  "id": "binary_exploitation_ecfcf23dd679",
  "category": "binary-exploitation",
  "title": "unsorted bin attack",
  "description": "# Unsorted Bin Attack\n\n{{#include ../../banners/hacktricks-training.md}}\n\n## Basic Information\n\nFor more information about what is an unsorted bin check this page:\n\n\n{{#ref}}\nbins-and-memory-allocations.md\n{{#endref}}\n\nUnsorted lists are able to write the address to `unsorted_chunks (av)` in the `bk` address of the chunk. Therefore, if an attacker can **modify the address of the `bk` pointer** in a chunk inside the unsorted bin, he could be able to **write that address in an arbitrary address** ",
  "payloads": [
    "# Unsorted Bin Attack",
    "{{#include ../../banners/hacktricks-training.md}}",
    "## Basic Information",
    "For more information about what is an unsorted bin check this page:",
    "{{#ref}}",
    "bins-and-memory-allocations.md",
    "{{#endref}}",
    "Unsorted lists are able to write the address to `unsorted_chunks (av)` in the `bk` address of the chunk. Therefore, if an attacker can **modify the address of the `bk` pointer** in a chunk inside the unsorted bin, he could be able to **write that address in an arbitrary address** which could be helpful to leak a Glibc addresses or bypass some defense.",
    "So, basically, this attack allows to **set a big number at an arbitrary address**. This big number is an address, which could be a heap address or a Glibc address. A traditional target was **`global_max_fast`** to allow to create fast bin bins with bigger sizes (and pass from an unsorted bin attack to a fast bin attack).",
    "- Modern note (glibc \u2265 2.39): `global_max_fast` became an 8\u2011bit global. Blindly writing a pointer there via an unsorted-bin write will clobber adjacent libc data and will not reliably raise the fastbin limit anymore. Prefer other targets or other primitives when running against glibc 2.39+. See \"Modern constraints\" below and consider combining with other techniques like a [large bin attack](large-bin-attack.md) or a [fast bin attack](fast-bin-attack.md) once you have a stable primitive.",
    "> [!TIP]",
    "> T> aking a look to the example provided in [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#principle) and using 0x4000 and 0x5000 instead of 0x400 and 0x500 as chunk sizes (to avoid Tcache) it's possible to see that **nowadays** the error **`malloc(): unsorted double linked list corrupted`** is triggered.",
    "> Therefore, this unsorted bin attack now (among other checks) also requires to be able to fix the doubled linked list so this is bypassed `victim->bk->fd == victim` or not `victim->fd == av (arena)`, which means that the address where we want to write must have the address of the fake chunk in its `fd` position and that the fake chunk `fd` is pointing to the arena.",
    "> [!CAUTION]",
    "> Note that this attack corrupts the unsorted bin (hence small and large too). So we can only **use allocations from the fast bin now** (a more complex program might do other allocations and crash), and to trigger this we must **allocate the same size or the program will crash.**"
  ],
  "source": "HackTricks",
  "references": [
    "/workspaces/hunter-skill/hacktricks/src/binary-exploitation/libc-heap/unsorted-bin-attack.md"
  ]
}