{
  "id": "binary_exploitation_b814a52038cd",
  "category": "binary-exploitation",
  "title": "double free",
  "description": "# Double Free\n\n{{#include ../../banners/hacktricks-training.md}}\n\n## Basic Information\n\nIf you free a block of memory more than once, it can mess up the allocator's data and open the door to attacks. Here's how it happens: when you free a block of memory, it goes back into a list of free chunks (e.g. the \"fast bin\"). If you free the same block twice in a row, the allocator detects this and throws an error. But if you **free another chunk in between, the double-free check is bypassed**, causing c",
  "payloads": [
    "# Double Free",
    "{{#include ../../banners/hacktricks-training.md}}",
    "## Basic Information",
    "If you free a block of memory more than once, it can mess up the allocator's data and open the door to attacks. Here's how it happens: when you free a block of memory, it goes back into a list of free chunks (e.g. the \"fast bin\"). If you free the same block twice in a row, the allocator detects this and throws an error. But if you **free another chunk in between, the double-free check is bypassed**, causing corruption.",
    "Now, when you ask for new memory (using `malloc`), the allocator might give you a **block that's been freed twice**. This can lead to two different pointers pointing to the same memory location. If an attacker controls one of those pointers, they can change the contents of that memory, which can cause security issues or even allow them to execute code.",
    "Example:",
    "#include <stdio.h>",
    "#include <stdlib.h>",
    "int main() {",
    "// Allocate memory for three chunks",
    "char *a = (char *)malloc(10);",
    "char *b = (char *)malloc(10);",
    "char *c = (char *)malloc(10);",
    "char *d = (char *)malloc(10);",
    "char *e = (char *)malloc(10);"
  ],
  "source": "HackTricks",
  "references": [
    "/workspaces/hunter-skill/hacktricks/src/binary-exploitation/libc-heap/double-free.md"
  ]
}