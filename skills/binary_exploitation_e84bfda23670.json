{
  "id": "binary_exploitation_e84bfda23670",
  "category": "binary-exploitation",
  "title": "free",
  "description": "# free\n\n{{#include ../../../banners/hacktricks-training.md}}\n\n## Free Order Summary <a href=\"#libc_free\" id=\"libc_free\"></a>\n\n(No checks are explained in this summary and some case have been omitted for brevity)\n\n1. If the address is null don't do anything\n2. If the chunk was mmaped, munmap it and finish\n3. Call `_int_free`:\n   1. If possible, add the chunk to the tcache\n   2. If possible, add the chunk to the fast bin\n   3. Call `_int_free_merge_chunk` to consolidate the chunk is needed and add",
  "payloads": [
    "# free",
    "{{#include ../../../banners/hacktricks-training.md}}",
    "## Free Order Summary <a href=\"#libc_free\" id=\"libc_free\"></a>",
    "(No checks are explained in this summary and some case have been omitted for brevity)",
    "1. If the address is null don't do anything",
    "2. If the chunk was mmaped, munmap it and finish",
    "3. Call `_int_free`:",
    "1. If possible, add the chunk to the tcache",
    "2. If possible, add the chunk to the fast bin",
    "3. Call `_int_free_merge_chunk` to consolidate the chunk is needed and add it to the unsorted list",
    "> Note: Starting with glibc 2.42, the tcache step can also take chunks up to a much larger size threshold (see \u201cRecent glibc changes\u201d below). This changes when a free lands in tcache vs. unsorted/small/large bins.",
    "## __libc_free <a href=\"#libc_free\" id=\"libc_free\"></a>",
    "`Free` calls `__libc_free`.",
    "- If the address passed is Null (0) don't do anything.",
    "- Check pointer tag"
  ],
  "source": "HackTricks",
  "references": [
    "/workspaces/hunter-skill/hacktricks/src/binary-exploitation/libc-heap/heap-memory-functions/free.md"
  ]
}