{
  "id": "binary_exploitation_41520aa67ef5",
  "category": "binary-exploitation",
  "title": "heap overflow",
  "description": "# Heap Overflow\n\n{{#include ../../banners/hacktricks-training.md}}\n\n## Basic Information\n\nA heap overflow is like a [**stack overflow**](../stack-overflow/index.html) but in the heap. Basically it means that some space was reserved in the heap to store some data and **stored data was bigger than the space reserved.**\n\nIn stack overflows we know that some registers like the instruction pointer or the stack frame are going to be restored from the stack and it could be possible to abuse this. In ca",
  "payloads": [
    "# Heap Overflow",
    "{{#include ../../banners/hacktricks-training.md}}",
    "## Basic Information",
    "A heap overflow is like a [**stack overflow**](../stack-overflow/index.html) but in the heap. Basically it means that some space was reserved in the heap to store some data and **stored data was bigger than the space reserved.**",
    "In stack overflows we know that some registers like the instruction pointer or the stack frame are going to be restored from the stack and it could be possible to abuse this. In case of heap overflows, there **isn't any sensitive information stored by default** in the heap chunk that can be overflowed. However, it could be sensitive information or pointers, so the **criticality** of this vulnerability **depends** on **which data could be overwritten** and how an attacker could abuse this.",
    "> [!TIP]",
    "> In order to find overflow offsets you can use the same patterns as in [**stack overflows**](../stack-overflow/index.html#finding-stack-overflows-offsets).",
    "### Stack Overflows vs Heap Overflows",
    "In stack overflows the arranging and data that is going to be present in the stack at the moment the vulnerability can be triggered is fairly reliable. This is because the stack is linear, always increasing in colliding memory, in **specific places of the program run the stack memory usually stores similar kind of data** and it has some specific structure with some pointers at the end of the stack part used by each function.",
    "However, in the case of a heap overflow, the used memory isn\u2019t linear but **allocated chunks are usually in separated positions of memory** (not one next to the other) because of **bins and zones** separating allocations by size and because **previous freed memory is used** before allocating new chunks. It\u2019s **complicated to know the object that is going to be colliding with the one vulnerable** to a heap overflow. So, when a heap overflow is found, it\u2019s needed to find a **reliable way to make the desired object to be next in memory** from the one that can be overflowed.",
    "One of the techniques used for this is **Heap Grooming** which is used for example [**in this post**](https://azeria-labs.com/grooming-the-ios-kernel-heap/). In the post it\u2019s explained how when in iOS kernel when a zone run out of memory to store chunks of memory, it expands it by a kernel page, and this page is splitted into chunks of the expected sizes which would be used in order (until iOS version 9.2, then these chunks are used in a randomised way to difficult the exploitation of these attacks).",
    "Therefore, in the previous post where a heap overflow is happening, in order to force the overflowed object to be colliding with a victim order, several **`kallocs` are forced by several threads to try to ensure that all the free chunks are filled and that a new page is created**.",
    "In order to force this filling with objects of a specific size, the **out-of-line allocation associated with an iOS mach port** is an ideal candidate. By crafting the size of the message, it\u2019s possible to exactly specify the size of `kalloc` allocation and when the corresponding mach port is destroyed, the corresponding allocation will be immediately released back to `kfree`.",
    "Then, some of these placeholders can be **freed**. The **`kalloc.4096` free list releases elements in a last-in-first-out order**, which basically means that if some place holders are freed and the exploit try lo allocate several victim objects while trying to allocate the object vulnerable to overflow, it\u2019s probable that this object will be followed by a victim object.",
    "### Example libc"
  ],
  "source": "HackTricks",
  "references": [
    "/workspaces/hunter-skill/hacktricks/src/binary-exploitation/libc-heap/heap-overflow.md"
  ]
}