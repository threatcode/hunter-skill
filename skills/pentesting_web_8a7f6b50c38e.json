{
  "id": "pentesting_web_8a7f6b50c38e",
  "category": "pentesting-web",
  "title": "request smuggling in http 2 downgrades",
  "description": "# Request Smuggling in HTTP/2 Downgrades\n\n{{#include ../../banners/hacktricks-training.md}}\n\nHTTP/2 is generally considered immune to classic request-smuggling because the length of each DATA frame is explicit. **That protection disappears as soon as a front-end proxy \u201cdowngrades\u201d the request to HTTP/1.x before forwarding it to a back-end**. The moment two different parsers (the HTTP/2 front-end and the HTTP/1 back-end) try to agree on where one request ends and the next begins, all the old desy",
  "payloads": [
    "# Request Smuggling in HTTP/2 Downgrades",
    "{{#include ../../banners/hacktricks-training.md}}",
    "HTTP/2 is generally considered immune to classic request-smuggling because the length of each DATA frame is explicit. **That protection disappears as soon as a front-end proxy \u201cdowngrades\u201d the request to HTTP/1.x before forwarding it to a back-end**. The moment two different parsers (the HTTP/2 front-end and the HTTP/1 back-end) try to agree on where one request ends and the next begins, all the old desync tricks come back \u2013 plus a few new ones.",
    "## Why downgrades happen",
    "1. Browsers already speak HTTP/2, but much legacy origin infrastructure still only understands HTTP/1.1.",
    "2. Reverse-proxies (CDNs, WAFs, load-balancers) therefore terminate TLS + HTTP/2 at the edge and **rewrite every request as HTTP/1.1** for the origin.",
    "3. The translation step has to create *both* `Content-Length` **and/or** `Transfer-Encoding: chunked` headers so that the origin can determine body length.",
    "Whenever the front-end trusts the HTTP/2 frame length **but** the back-end trusts CL or TE, an attacker can force them to disagree.",
    "## Two dominant primitive classes",
    "| Variant | Front-end length | Back-end length | Typical payload |",
    "|---------|-----------------|-----------------|-----------------|",
    "| **H2.TE** | HTTP/2 frame | `Transfer-Encoding: chunked` | Embed an extra chunked message body whose final `0\\r\\n\\r\\n` is *not* sent, so the back-end waits for the attacker-supplied \u201cnext\u201d request. |",
    "| **H2.CL** | HTTP/2 frame | `Content-Length` | Send a *smaller* CL than the real body, so the back-end reads past the boundary into the following request. |",
    "> These are identical in spirit to classic TE.CL / CL.TE, just with HTTP/2 replacing one of the parsers.",
    "## Identifying a downgrade chain"
  ],
  "source": "HackTricks",
  "references": [
    "/workspaces/hunter-skill/hacktricks/src/pentesting-web/http-request-smuggling/request-smuggling-in-http-2-downgrades.md"
  ]
}