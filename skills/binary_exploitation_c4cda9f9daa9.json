{
  "id": "binary_exploitation_c4cda9f9daa9",
  "category": "binary-exploitation",
  "title": "common exploiting problems unsafe relocation fixups",
  "description": "# Unsafe Relocation Fixups in Asset Loaders\n\n{{#include ../banners/hacktricks-training.md}}\n\n## Why asset relocations matter\n\nMany legacy game engines (Granny 3D, Gamebryo, etc.) load complex assets by:\n\n1. Parsing a header and section table.\n2. Allocating one heap buffer per section.\n3. Building a `SectionArray` that stores the base pointer of every section.\n4. Applying relocation tables so that pointers embedded inside the section data get patched to the right target section + offset.\n\nWhen th",
  "payloads": [
    "# Unsafe Relocation Fixups in Asset Loaders",
    "{{#include ../banners/hacktricks-training.md}}",
    "## Why asset relocations matter",
    "Many legacy game engines (Granny 3D, Gamebryo, etc.) load complex assets by:",
    "1. Parsing a header and section table.",
    "2. Allocating one heap buffer per section.",
    "3. Building a `SectionArray` that stores the base pointer of every section.",
    "4. Applying relocation tables so that pointers embedded inside the section data get patched to the right target section + offset.",
    "When the relocation handler blindly trusts attacker-controlled metadata, every relocation becomes a potential arbitrary read/write primitive. In *Anno 1404: Venice*, `granny2.dll` ships the following helper:",
    "<details>",
    "<summary>`GrannyGRNFixUp_0` (trimmed)</summary>",
    "int *__cdecl GrannyGRNFixUp_0(DWORD RelocationCount,",
    "Relocation *PointerFixupArray,",
    "int *SectionArray,",
    "char *destination)"
  ],
  "source": "HackTricks",
  "references": [
    "/workspaces/hunter-skill/hacktricks/src/binary-exploitation/common-exploiting-problems-unsafe-relocation-fixups.md"
  ]
}