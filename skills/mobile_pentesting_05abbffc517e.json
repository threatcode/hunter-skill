{
  "id": "mobile_pentesting_05abbffc517e",
  "category": "mobile-pentesting",
  "title": "in memory jni shellcode execution",
  "description": "# Android In-Memory Native Code Execution via JNI (shellcode)\n\n{{#include ../../banners/hacktricks-training.md}}\n\nThis page documents a practical pattern to execute native payloads fully in memory from an untrusted Android app process using JNI. The flow avoids creating any on-disk native binary: download raw shellcode bytes over HTTP(S), pass them to a JNI bridge, allocate RX memory, and jump into it.\n\nWhy it matters\n- Reduces forensic artifacts (no ELF on disk)\n- Compatible with \u201cstage-2\u201d nati",
  "payloads": [
    "# Android In-Memory Native Code Execution via JNI (shellcode)",
    "{{#include ../../banners/hacktricks-training.md}}",
    "This page documents a practical pattern to execute native payloads fully in memory from an untrusted Android app process using JNI. The flow avoids creating any on-disk native binary: download raw shellcode bytes over HTTP(S), pass them to a JNI bridge, allocate RX memory, and jump into it.",
    "Why it matters",
    "- Reduces forensic artifacts (no ELF on disk)",
    "- Compatible with \u201cstage-2\u201d native payloads generated from an ELF exploit binary",
    "- Matches tradecraft used by modern malware and red teams",
    "High-level pattern",
    "1) Fetch shellcode bytes in Java/Kotlin",
    "2) Call a native method (JNI) with the byte array",
    "3) In JNI: allocate RW memory \u2192 copy bytes \u2192 mprotect to RX \u2192 call entrypoint",
    "Minimal example",
    "Java/Kotlin side",
    "```java",
    "public final class NativeExec {"
  ],
  "source": "HackTricks",
  "references": [
    "/workspaces/hunter-skill/hacktricks/src/mobile-pentesting/android-app-pentesting/in-memory-jni-shellcode-execution.md"
  ]
}