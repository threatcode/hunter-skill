{
  "id": "binary_exploitation_02b307486410",
  "category": "binary-exploitation",
  "title": "gnu obstack function pointer hijack",
  "description": "# GNU obstack function-pointer hijack\n\n{{#include ../../banners/hacktricks-training.md}}\n\n## Overview\n\nGNU obstacks embed allocator state together with two indirect call targets:\n\n- `chunkfun` (offset `+0x38`) with signature `void *(*chunkfun)(void *, size_t)`\n- `freefun` (offset `+0x40`) with signature `void (*freefun)(void *, void *)`\n- `extra_arg` and a `use_extra_arg` flag select whether `_obstack_newchunk` calls `chunkfun(new_size)` or `chunkfun(extra_arg, new_size)`\n\nIf an attacker can cor",
  "payloads": [
    "# GNU obstack function-pointer hijack",
    "{{#include ../../banners/hacktricks-training.md}}",
    "## Overview",
    "GNU obstacks embed allocator state together with two indirect call targets:",
    "- `chunkfun` (offset `+0x38`) with signature `void *(*chunkfun)(void *, size_t)`",
    "- `freefun` (offset `+0x40`) with signature `void (*freefun)(void *, void *)`",
    "- `extra_arg` and a `use_extra_arg` flag select whether `_obstack_newchunk` calls `chunkfun(new_size)` or `chunkfun(extra_arg, new_size)`",
    "If an attacker can corrupt an application-owned `struct obstack *` or its fields, the next growth of the obstack (when `next_free == chunk_limit`) triggers an indirect call through `chunkfun`, enabling code execution primitives.",
    "## Primitive: size_t desync \u2192 0-byte allocation \u2192 pointer OOB write",
    "A common bug pattern is using a **32-bit register** to compute `sizeof(ptr) * count` while storing the logical length in a 64-bit `size_t`.",
    "- Example: `elements = obstack_alloc(obs, sizeof(void *) * size);` is compiled as `SHL EAX,0x3` for `size << 3`.",
    "- With `size = 0x20000000` and `sizeof(void *) = 8`, the multiplication wraps to `0x0` in 32-bit, so the pointer array is **0 bytes**, but the recorded `size` remains `0x20000000`.",
    "- Subsequent `elements[curr++] = ptr;` writes perform **8-byte OOB pointer stores** into adjacent heap objects, giving a controlled cross-object overwrite primitive.",
    "## Leaking libc via `obstack.chunkfun`",
    "1. Place two heap objects adjacent (e.g., two stacks built with separate obstacks)."
  ],
  "source": "HackTricks",
  "references": [
    "/workspaces/hunter-skill/hacktricks/src/binary-exploitation/libc-heap/gnu-obstack-function-pointer-hijack.md"
  ]
}