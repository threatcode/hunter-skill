{
  "id": "network_services_pentesting_4397c963d44c",
  "category": "network-services-pentesting",
  "title": "1099 pentesting java rmi",
  "description": "# 1098/1099/1050 - Pentesting Java RMI - RMI-IIOP\n\n{{#include ../banners/hacktricks-training.md}}\n\n\n## Basic Information\n\n_Java Remote Method Invocation_, or _Java RMI_, is an object oriented _RPC_ mechanism that allows an object located in one _Java virtual machine_ to call methods on an object located in another _Java virtual machine_. This enables developers to write distributed applications using an object-oriented paradigm. A short introduction to _Java RMI_ from an offensive perspective ca",
  "payloads": [
    "# 1098/1099/1050 - Pentesting Java RMI - RMI-IIOP",
    "{{#include ../banners/hacktricks-training.md}}",
    "## Basic Information",
    "_Java Remote Method Invocation_, or _Java RMI_, is an object oriented _RPC_ mechanism that allows an object located in one _Java virtual machine_ to call methods on an object located in another _Java virtual machine_. This enables developers to write distributed applications using an object-oriented paradigm. A short introduction to _Java RMI_ from an offensive perspective can be found in [this blackhat talk](https://youtu.be/t_aw1mDNhzI?t=202).",
    "**Default port:** 1090,1098,1099,1199,4443-4446,8999-9010,9999",
    "PORT      STATE SERVICE      VERSION",
    "1090/tcp  open  ssl/java-rmi Java RMI",
    "9010/tcp  open  java-rmi     Java RMI",
    "37471/tcp open  java-rmi     Java RMI",
    "40259/tcp open  ssl/java-rmi Java RMI",
    "Usually, only the default _Java RMI_ components (the _RMI Registry_ and the _Activation System_) are bound to common ports. The _remote objects_ that implement the actual _RMI_ application are usually bound to random ports as shown in the output above.",
    "_nmap_ has sometimes troubles identifying _SSL_ protected _RMI_ services. If you encounter an unknown ssl service on a common _RMI_ port, you should further investigate.",
    "## RMI Components",
    "To put it in simple terms, _Java RMI_ allows a developer to make a _Java object_ available on the network. This opens up a _TCP_ port where clients can connect and call methods on the corresponding object. Despite this sounds simple, there are several challenges that _Java RMI_ needs to solve:",
    "1. To dispatch a method call via _Java RMI_, clients need to know the IP address, the listening port, the implemented class or interface and the `ObjID` of the targeted object (the `ObjID` is a unique and random identifier that is created when the object is made available on the network. It is required because _Java RMI_ allows multiple objects to listen on the same _TCP_ port)."
  ],
  "source": "HackTricks",
  "references": [
    "/workspaces/hunter-skill/hacktricks/src/network-services-pentesting/1099-pentesting-java-rmi.md"
  ]
}