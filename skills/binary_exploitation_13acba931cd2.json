{
  "id": "binary_exploitation_13acba931cd2",
  "category": "binary-exploitation",
  "title": "common exploiting problems",
  "description": "# Common Exploiting Problems\n\n{{#include ../banners/hacktricks-training.md}}\n\n## FDs in Remote Exploitation\n\nWhen sending an exploit to a remote server that calls **`system('/bin/sh')`** for example, this will be executed in the server process ofc, and `/bin/sh` will expect input from stdin (FD: `0`) and will print the output in stdout and stderr (FDs `1` and `2`). So the attacker won't be able to interact with the shell.\n\nA way to fix this is to suppose that when the server started it created t",
  "payloads": [
    "# Common Exploiting Problems",
    "{{#include ../banners/hacktricks-training.md}}",
    "## FDs in Remote Exploitation",
    "When sending an exploit to a remote server that calls **`system('/bin/sh')`** for example, this will be executed in the server process ofc, and `/bin/sh` will expect input from stdin (FD: `0`) and will print the output in stdout and stderr (FDs `1` and `2`). So the attacker won't be able to interact with the shell.",
    "A way to fix this is to suppose that when the server started it created the **FD number `3`** (for listening) and that then, your connection is going to be in the **FD number `4`**. Therefore, it's possible to use the syscall **`dup2`** to duplicate the stdin (FD 0) and the stdout (FD 1) in the FD 4 (the one of the connection of the attacker) so it'll make feasible to contact the shell once it's executed.",
    "[**Exploit example from here**](https://ir0nstone.gitbook.io/notes/types/stack/exploiting-over-sockets/exploit):",
    "```python",
    "from pwn import *",
    "elf = context.binary = ELF('./vuln')",
    "p = remote('localhost', 9001)",
    "rop = ROP(elf)",
    "rop.raw('A' * 40)",
    "rop.dup2(4, 0)",
    "rop.dup2(4, 1)",
    "rop.win()"
  ],
  "source": "HackTricks",
  "references": [
    "/workspaces/hunter-skill/hacktricks/src/binary-exploitation/common-exploiting-problems.md"
  ]
}