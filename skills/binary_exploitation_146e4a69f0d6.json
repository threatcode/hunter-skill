{
  "id": "binary_exploitation_146e4a69f0d6",
  "category": "binary-exploitation",
  "title": "pixel bigwave bigo job timeout uaf kernel write",
  "description": "# Pixel BigWave BIGO timeout race UAF \u2192 2KB kernel write from mediacodec\n\n{{#include ../../banners/hacktricks-training.md}}\n\n## TL;DR\n\n- From the SELinux-confined **mediacodec** context, `/dev/bigwave` (Pixel AV1 hardware accelerator) is reachable. A backlog of jobs makes `BIGO_IOCX_PROCESS` hit its **16s wait_for_completion_timeout()** and return while the worker thread concurrently dequeues the same inline `job` structure.\n- Closing the FD immediately frees `struct bigo_inst` (which embeds `st",
  "payloads": [
    "# Pixel BigWave BIGO timeout race UAF \u2192 2KB kernel write from mediacodec",
    "{{#include ../../banners/hacktricks-training.md}}",
    "## TL;DR",
    "- From the SELinux-confined **mediacodec** context, `/dev/bigwave` (Pixel AV1 hardware accelerator) is reachable. A backlog of jobs makes `BIGO_IOCX_PROCESS` hit its **16s wait_for_completion_timeout()** and return while the worker thread concurrently dequeues the same inline `job` structure.",
    "- Closing the FD immediately frees `struct bigo_inst` (which embeds `struct bigo_job`). The worker reconstructs `inst = container_of(job, ...)` and later uses freed fields such as **`job->regs`** inside `bigo_run_job()`, yielding a **Use-After-Free on the inline job/inst**.",
    "- `bigo_pull_regs(core, job->regs)` performs `memcpy_fromio(regs, core->base, core->regs_size)`. By reclaiming the freed slab and overwriting `job->regs`, an attacker gets a **~2144-byte arbitrary kernel write** to a chosen address, with partial control of the bytes by pre-programming register values before the timeout.",
    "## Attack surface mapping (SELinux \u2192 /dev reachability)",
    "- Use tools like **DriverCartographer** to enumerate device nodes accessible from a given SELinux domain. Despite mediacodec\u2019s constrained policy (software decoders should stay in an isolated context), `/dev/bigwave` remained reachable, exposing a large attack surface to post-media-RCE code.",
    "## Vulnerability: BIGO_IOCX_PROCESS timeout vs worker",
    "- Flow: ioctl copies user register buffer into `job->regs`, queues the inline `job`, then `wait_for_completion_timeout(..., 16s)`. On timeout it tries to dequeue/cancel and returns to userspace.",
    "- Meanwhile `bigo_worker_thread` may have just dequeued the same `job`:",
    "inst = container_of(job, struct bigo_inst, job);",
    "bigo_push_regs(core, job->regs);",
    "bigo_pull_regs(core, job->regs);   // memcpy_fromio(regs, core->base, core->regs_size)",
    "*(u32 *)(job->regs + BIGO_REG_STAT) = status;"
  ],
  "source": "HackTricks",
  "references": [
    "/workspaces/hunter-skill/hacktricks/src/binary-exploitation/linux-kernel-exploitation/pixel-bigwave-bigo-job-timeout-uaf-kernel-write.md"
  ]
}